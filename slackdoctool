#!/bin/bash
# Author: Matthew Fillpot
# Created: 2012-12-28
# License: BSD
VERSION="0.1.0"
#
# Description
# -------------------------------------------------------
# Toolkit used to simplify offline editing of slackdocs
#  wiki content for http://docs.slackware.com
#


#------ TODO List -------
#   1. See if the script is causing terminal wrapping issues from font colors and fix them
#   12. Add a page to the wiki with vim optimizations and refer to them in the script
#   13. Clean up the script
#   14. Add hooks for IsOnline where appropriate
#   15. Make a function to write list of templates into an array using the
#     read line function
#   15. Change SetTemps to use the function to set templates
#   16. Change RefreshTemplates to use the function to set templates

# Define the path to the repo directory
TMP_DIR="/tmp"

# Define the variables
EXTENSION="slackdoc"
FILETYPE="slackdocs"
SYNF_VIM="slackdocs.vim"
SD_DIR="${HOME}/slackdocs"
SYNTAX_DIR="${REPO_PATH}/syntax_files"
TEMPLATE_DIR="${SD_DIR}/templates"
TEMPLATE_IND=""
DOC_TITLE=${DOC_TITLE:-"new"}

# Currently pointing tomf_test, needs to be movedto master when stable
GIT_URL="https://raw.github.com/mfillpot/slackdoc_templates/mfillpot"
VERSION_URL="${GIT_URL}/versions.txt"
SCRIPT_URL="${GIT_URL}/slackdoctool"
SYNTAX_URL="${GIT_URL}/syntax_files"

SD_URL="http://docs.slackware.com"
TEMP_URL="${SD_URL}/wiki:user:mfillpot:template_list"
TEMP_FILE="${SD_DIR}/templates.txt"

# Set Output font colors
#BLDTXT='\e[1m%s'
BLDTXT=$(tput bold)
#NRMTXT='\e[0m%s'
NRMTXT=$(tput sgr0)
#ERRTXT='\e[1;31m'
ERRTXT=$(tput setaf 1)
SCSTXT=$(tput setaf 2)

#BLACK=$(tput setaf 0)
#RED=$(tput setaf 1)
#GREEN=$(tput setaf 2)
#YELLOW=$(tput setaf 3)
#LIME_YELLOW=$(tput setaf 190)
#POWDER_BLUE=$(tput setaf 153)
#BLUE=$(tput setaf 4)
#MAGENTA=$(tput setaf 5)
#CYAN=$(tput setaf 6)
#WHITE=$(tput setaf 7)
#BRIGHT=$(tput bold)
#NORMAL=$(tput sgr0)
#BLINK=$(tput blink)
#REVERSE=$(tput smso)
#UNDERLINE=$(tput smul)

GetSyntaxExample () {
      PullPage "wiki:syntax" ${SD_DIR}
      WriteText 0 "${NRMTXT}" "The example syntax file is now located at ${SD_DIR}/wiki-syntax.${EXTENSION}" 1
}

PrepSyntax() {
  case "${SYNAPP}" in
    vim)
      VImSyntax
      ;;
    kate)
      KateSyntax
      ;;
    *)
      PrintError "Cannot set syntax info for ${SYNAPP}, please contact the authors of slackdoctool if you want it included."
      exit 1
      ;;
  esac
}

VimSyntax() {
  # Update/ Appends the necessary directive to the users .vimrc
  #  file to set syntax highlighting for slackdocs

  local VIMRC="${HOME}/.vimrc"

  wget ${SYNTAX_URL}/${SYNF_VIM} --output-document=${SD_DIR}/.${SYNF_VIM}

  # removes existing slackdoc syntax template lines if they exist
  sed -i /${FILETYPE}/d ${VIMRC}

  # Write the new lines to the vimrc file
  echo "\" Add a pointer to the ${FILETYPE} vim syntax file">>${VIMRC}
  echo "au BufRead,BufNewFile *.${EXTENSION} set filetype=${FILETYPE}">>${VIMRC}
  echo "au! Syntax ${FILETYPE} source ${SD_DIR}/.${SYNF_VIM}">>${VIMRC}

  PrintText 2 "${SCSTXT}" "The script has added the following lines to your vimrc file" 1
  cat ${VIMRC} | grep ${FILETYPE}
  printf "\n"
}

KateSyntax() {
  PrintText 2 "${BLDTXT}" \
          "To implement syntax highlighting to slackdoc articles in kate you need to enable the MediaWiki syntax highlighting by going to Tools -> Highlighting -> Markup -> Mediawiki." 1
}

PullTemplates() {
	# Pulls the listed template files into the templates directory

  # Checks if the templte directory exists
	if [ ! -d ${TEMPLATE_DIR} ]; then
    mkdir ${TEMPLATE_DIR}
  fi
  
  # Populates the TEMPS array
  SetTemps

  # Pulls the templates listed in the TEMPS array.
	for TEMPLATE in "${TEMPS[@]}"
  do
    PullPage "templates:${TEMPLATE}" "${TEMPLATE_DIR}"
  done
  PrintText 2 "${SCSTXT}" "All templates have been successfully retrieved." 1
}

SetTemps() {
  # Sets an array with the contents of the template index 
  if [ ! -f ${TEMP_FILE} ]; then
    RefreshTemplates
  else
    TEMPS=( $(cat ${TEMP_FILE}) )
  fi
}

RefreshTemplates() {
  # Refresh the list of available templates

  # Check if the directory structure exists
  if [ ! -f ${TEMP_FILE} ]; then
    BuildStructure
  fi
  
  PrintText 2 "${BLDTXT}"  "Refreshing the list of available templates..." 1
  lynx -dump ${TEMP_URL} | awk -F: '/templates:/ {print $NF}'>${TEMP_FILE}
  
  # Make the order of the templates more structured
  sort ${TEMP_FILE} -o ${TEMP_FILE}

  # Populates the TEMPS array with a list of available templates
  TEMPS=( $(cat $TEMP_FILE) )
}

# Verified
AvailableTemplates() {
  # Displays a list of available templates and usage
  
  # Make sure that the TEMPS array is set
  SetTemps

  printf "\n%s\n" "To create a new document using a template type:"
  printf "\n\e[1m%s\e[0m%s\n" "slackdoctool new template_number document_title"
  printf "\n%s\n\n" "The following templates are available:"
  
	# Loop over the TEMPS array to display available templates 
  for i in ${!TEMPS[*]}
  do
    printf "%4d: %s\n" $i ${TEMPS[$i]}
  done
  printf "\n"
}

BuildStructure() 
{
  # Accepts no arguments, builds directory structure

  if [ ! -d ${TEMPLATE_DIR} ]; then
    printf "\n${ERRTXT}%s${NRMTXT}\n" "The user directory at ${SD_DIR} does not exist"
    read -p "Would you like to create it? (Y/N) :" yn
    case ${yn} in
    [Yy*]* )
      mkdir -v ${SD_DIR}
      if [ ! -d ${TEMPLATE_DIR} ]; then
        mkdir -v ${TEMPLATE_DIR}
      fi
      ;;
    * )
      printf "\n${ERRTXT}%s${NRMTXT}\n" "Cannot resume without directory in place, Terminating."
      exit 1
      ;;
    esac
  fi
}

IsOnline() {
  # Checks if the computer and/or github is online
  ping -c 2 www.github.com > /dev/null
  if [ $? -ne 0 ]; then
    return 1
  else
    return 0
  fi
}

PullPage() {
  # Pulls the single page from $1 into the location at $2

  local EXTRACTLINE="?do=export_raw"

  # Page holds the name of the requested page
  local PAGE=${1}

  # If destination does not include ending slask add it
  if [[ ${2} == *"/" ]]; then
    local DESTDIR="${2}"
  else
    local DESTDIR="${2}/"
  fi

  if [ ! -d ${DESTDIR} ]; then
    WriteText 2 "${ERRTXT}" "The ${DESTDIR} directory does not exist, terminating action" 1
    exit 1
  fi

  # if requested page includs base url remove it so output page can be 
  #  determined
  if [[ "${PAGE}" == *"${SD_URL}"* ]]; then
    local PAGE="$(echo "${PAGE}"|cut -d "/" -f 4)"
  fi

  # Set output file name
  if [ "${2}" = "${TEMPLATE_DIR}" ]; then
    local OF="$(echo "${PAGE}"|sed 's/:/-/g'|sed 's/templates-//g').${EXTENSION}"
  else
    local OF="$(echo "${PAGE}"|sed 's/:/-/g').${EXTENSION}"
  fi

  # If output file exists remove it
  if [ -e ${DESTDIR}${OF} ]; then
    rm ${DESTDIR}${OF}
  fi

  # Append the base url to the page address
  local PAGE=${SD_URL}/${PAGE}

  if [ -e ${DESTDIR}${OF} ]; then
    printf "\n${ERRTXT}%s${NRMTXT}\n" "${DESTDIR}${OF} exists"
    read -p "Would you like to overwrite it? " yn
    case ${yn} in
    [Yy]* )

      rm ${DESTDIR}${OF}

      FinishPull ${PAGE}${EXTRACTLINE} ${PAGE} ${DESTDIR}${OF}
      ;;
    * )
      printf ""
      ;;
    esac
  else
    FinishPull ${PAGE}${EXTRACTLINE} ${PAGE} ${DESTDIR}${OF}
  fi
}

FinishPull() {
  # retrieve the page
  #
  # Arg1 = URL
  # Arg2 = Descriptive Name
  # Arg3 = Output File Name
  
  F_STATUS=""
  local URL=${1}
  local DESCRIPT=${2}
  local OUTFILE=${3}
  
  local FAILTEXT="epub_LoadScript"

  wget ${URL} --output-document=${OUTFILE}

  # Test for a valid pull and display associated message
  if [ -n "$(cat ${OUTFILE}|grep ${FAILTEXT})" ]; then
    rm ${OUTFILE}
    WriteText 2 "${ERRTXT}" "${DESCRIPT} does not exist" 1
	unset F_STATUS
  else
    WriteText 2 "${SCSTXT}" "${OUTFILE} is ready to edit" 1
	F_STATUS=0
  fi
}

PullFromList() {
  # This function is intended to allow a user to specificy a text file
  #  list of pages to retreive and pull them into the desired directory
  #
  # Arg1 = List File
  # Arg2 = Destination Dir

  local LISTFILE=${1}
  local DESTDIR=${2}
  declare -a FETCHED=()
  declare -a FAILED=()
  
  while read PAG
  do
	  PullPage ${PAG} ${DESTDIR} 
	  [ -z "$F_STATUS" ] && FAILED+=("${PAG}") || FETCHED+=("${PAG}")
  done < ${LISTFILE}
  echo 
  echo "Fetched ${#FETCHED[@]} document(s): ${FETCHED[@]}"
  echo "Failed to fetch ${#FAILED[@]} document(s): ${FAILED[@]}"
  echo
}

CreateNew() {
  # Copies a template into a new filename and sets it for editing

  
	BuildStructure

  # Pull the templates if they are not present
  if [ ! -d ${TEMPLATE_DIR} ]; then
    PullTemplates
  fi
  
  TEMPLATE_FILE=${TEMPLATE_DIR}/${TEMPS[${TEMPLATE_IND}]}.${EXTENSION}
  OUTPUT_FILE=${SD_DIR}/${DOC_TITLE}.${EXTENSION}

  if [ -f ${TEMPLATE_FILE} ]; then

    # Question: Why are the files being copied into the clipboard and opened
    # in vim?

    # Check if the output file already exists. If so, edit it.
    if [ -f ${OUTPUT_FILE} ]; then
      vim ${OUTPUT_FILE}
      CopyToClipboard ${OUTPUT_FILE} "1"

      # If the output file does not exist, copy the template, rename and
      # edit it.
    else
      cp ${TEMPLATE_FILE} ${OUTPUT_FILE} && vim ${OUTPUT_FILE}
      CopyToClipboard ${OUTPUT_FILE} "1"
    fi
  else
    printf "\n${ERRTXT}%s${NRMTXT}\n" \
      "There have been problems accessing ${TEMPLATE_FILE}"
    printf "${NRMTXT}%s${BLDTXT} %s${NRMTXT}\n" \
      "Please download template files first by running:" \
        "slackdoctool fetch templates"
    exit 1
  fi
}

CopyToClipboard()
{
  # Copies a file to the clipboard for pasteing online
  #
  # Arg1 = File Name
  # Arg2 = 1 to turn confirmations ON, else confirmations OFF

  local FILENAME=${1}
  local CONFS=${2}


  ls /var/log/packages | grep "\<xclip\>" > /dev/null
  if [ $? -eq 0 ]; then
    printf "\n${ERRTXT}%s${NRMTXT}\n" \
      "xclip is not installed, the contents will need to be manually copied."
    return 1
  fi

  if [ -f ${FILENAME} ]
  then
    if [ "${CONFS}" = "1" ]
    then
      # if xclip is installed on the system, 
      # copy the contents of the file to clipboard
      read -p "Would you like the contents of ${FILENAME} to be copied to the clipboard [y/N]? " yn
      case ${yn} in
      [Yy*]* )
        cat ${FILENAME} | xclip -selection clipboard
        printf "\n${SCSTXT}%s${NRMTXT}\n" \
          "The contents of ${FILENAME} has been copied to clipboard."
        return 1
        ;;
      esac
    else
      cat ${FILENAME} | xclip -selection clipboard
    fi
  else
    printf "\n${ERRTXT}%s${NRMTXT}\n" \
      "The File ${FILENAME} does not exist, terminating action."
    exit 1
  fi
}

CheckUpdate() {
# Checks githhub for a new version of the file and downloads it

  NEW_VERSION=$(lynx -dump ${VERSION_URL} | grep slackdoctool | cut -d "=" -f 2)
  printf "\n${BLDTXT}%s${NRMTXT}\n" \
    "Checking for an updated script."
  if [ "${NEW_VERSION}" = "${VERSION}" ]; then
    printf "\n${SCSTXT}%s${NRMTXT}\n" \
      "Your copy is up to date"
  else 
    printf "\n${BLDTXT}%s${NRMTXT}\n" \
      "A new version is available."
    read -p "Would you like to fetch version ${NEW_VERSION} [y/N]? " yn
    case ${yn} in
    [Yy*]* )
      wget ${SCRIPT_URL} --output-document=${TMP_DIR}/slackdoctool
      if [ "$?" = "0" ]; then
#SCSTXT=$(tput setaf 153)
        printf "\n${SCSTXT}%s${NRMTXT}\n" \
          "Version ${VERSION} has been saved to ${TMP_DIR}/slackdoctool."
      else
        printf "\n${ERRTXT}%s${NRMTXT}\n" \
          "The update failed, try again later."
      fi
      ;;
    * )
      printf "\n${ERRTXT}%s${NRMTXT}\n" \
        "Download Declined, terminating action."
      ;;
    esac
  fi
}

# Copied to Here

HelpArg() {

  OPT="${1}"
  ARG="${2}"
  DISTXT="${3}"

  IND=8
  HIND=$((${IND}-4))
  SPC=2

  PrintText ${HIND} "${BLDTXT}" "${OPT}  ${ARG}" 1
  PrintText ${IND} "${NRMTXT}" "${DISTXT}" 1

}

PrintError() {
  # Arg1 = Text To Display

  #Writes the string in the error color with a blank lin following it

  local ERROR_TEXT="${1}"

  PrintText 2 "${ERRTXT}" "${ERROR_TEXT}" 1
  PrintText 0 "" "" 1
}

PrintText() {
  # Arg1 = Indent Count
  # Arg2 = Font Formatting
  # Arg3 = Input Text
  # Arg4 = 1 - newline, 0 - no newline

  INDENT=${1}
  FORMAT="${2}"
  INPUTTEXT="${3}"
  if [ "${4}" = "1" ]; then
    NEWLINE="\n"
  else
    NEWLINE=""
  fi

  NEWSTR=""
  for WORD in ${INPUTTEXT}
  do
    if [ "${NEWSTR}" = "" ]; then
        NEWSTR="${WORD}"
    else
      TSTSTR="${NEWSTR}${WORD} "
      if [ ${#TSTSTR} -lt $(($(tput cols)-${INDENT})) ]; then 
        NEWSTR="${NEWSTR} ${WORD}"
      else
        printf "%*s" ${INDENT} ""
        printf "${FORMAT}%s${NRMTXT}${NEWLINE}" "${NEWSTR}"
        NEWSTR="${WORD}"
      fi
    fi
  done

  printf "%*s" ${INDENT} ""
  printf "${FORMAT}%s${NRMTXT}${NEWLINE}" "${NEWSTR}"
}

  # The help dialog
DisplayHelp() {
# Displays the help text

  # Definte the basic formatting for each level of the output
  WriteText 4 "${SCSTXT}" "Slackware Documentation Project - Off-line Tools" 1
  WriteText 4 "${BLDTXT}" "Version: ${VERSION}" 1
  WriteText 0 "" "" 1
  WriteText 6 "${BLDTXT}" "Slackdocs Website:" 1
  WriteText 8 "${NRMTXT}" "http://docs.slackware.com" 1
  WriteText 6 "${BLDTXT}" "Project URL:" 1
  WriteText 8 "${NRMTXT}" "https://github.com/mfillpot/slackdoc_templates" 1
  WriteText 0 "" "" 1
  #printf "${BLDTXT}%s${NRMTXT} %s\n" "Version:" "${VERSION}"

  #printf "\n"
  WriteText 0 "${BLDTXT}" "OPTIONS" 1
  HelpArg "-h" "" "Display this dialog"
  HelpArg "-S" "" "Fetch the syntax file(s)."
  HelpArg "-s" "Application Name" "Apply the syntaz highlighting file for the chosen app. Valid options are kate and vim."
  HelpArg "-T" "" "Fetch all templates from the website"
  HelpArg "-w" "URL" "Fetch an article from the slackdoc URL given. If the -d argument is not given it will save in the slackdocs directory."
  HelpArg "-f" "File" "Fetch articles from the dlsckdoc wiki from the list contained within the specified file. If no -d option is given it will save the documents into the slackdocs directory."
  HelpArg "-d" "Destination Directory" "Only valid with the -f and -w arguments. This specifies the destination directory which will containthe fetched file(1)."
  HelpArg "-c" "File" "Copy the file's contents into the clipboard."
  HelpArg "-n" "Template Number" "Create a new file based upon the specified template. The template list can be viewed with the -l option."
  HelpArg "-o" "FileName" "Only used with the -n option. The argument will containthe name of the new output file."
  HelpArg "-r" "" "Refresh the list of templates from the slackdocs wiki."
  HelpArg "-l" "" "List all available templates."
  HelpArg "-u" "" "Check for and download updates to this script."
  HelpArg "-a" "" "Download all base and syntax files from the slackdocs wiki."
  #printf "${L1}" \
  #  "help" \
  #    "- Displays this dialog"
  #Printf "${L1}" \
  #  "fetch" \
  #    "- Fetches a wiki formatted page from docs.slackware.com."
  #printf "${L2}" \
  #  "{URL}" \
  #    "- Can be from the site root or the whole address."
  #printf "${L3}" \
  #  "{Destination Directory}" \
  #    "- if ommited it will be in the default slackdoc directory."
  #printf "${L2}" \
  #  "{FILE}" \
  #    "- A file that contains a list of pages to fetch."
  #printf "${L3}" \
  #  "{Destination Directory}" \
  #    "- Optional: if ommited it will be in the default slackdoc directory."
  #
  #printf "${L2}" \
  #  "templates" \
  #    "- Can be from the site root or the whole address."
  #printf "${L2}" \
  #  "syntax" \
  #    "- Fetch the example syntax file from slackdocs wiki."
  #
  #printf "${L1}" \
  #  "templates" \
  #    "- Displays a list of templates that are available."
  #printf "${L2}" \
  #  "[refresh]" \
  #    "- Optional: Refreshes a list of available templates."
  #
  #printf "${L1}" \
  #  "new" \
  #    "- Creates a new document based on a template."
  #printf "${L2}" \
  #  "index_number" \
  #    "- Template index number."
  #printf "${L3}" \
  #  "title" \
  #    "- Document title."
  #
  #printf "${L1}" \
  #  "syntax" \
  #    "- Applies the associated syntax file for use."
  #printf "${L2}" \
  #  "vim" \
  #    "- Applies the changes to .vimrc to enable slackdoc syntax highlighting."
  #printf "${L2}" \
  #  "kate" \
  #    "- Display instruction for enabling syntax highlighting in kate."
  #
  #printf "${L1}" \
  #  "copy" \
  #    "- Copies the contents of a file to the clipboard."
  #printf "${L2}" \
  #  "{FileName}" \
  #    "- The file to copy."
  #
  #printf "${L1}" \
  #  "update" \
  #    "- Check for and download this scripts update"
  #printf "\n"
}

  # The old Argument checkin mechanism
OldMenu() {

case "${1}" in
  fetch)
    if [ "${2}" = "templates" ]; then
      # If too many args then display help
      if test $# -le 2
      then
        BuildStructure
        PullTemplates
        AvailableTemplates
      else
        printf "${ERRTXT}%s${NRMTXT}\n" \
          "Too Many Arguments"
        DisplayHelp
        exit 1
      fi
    else
      # If too many args then display help
      if [[ $# -le 3 ]]; then
        # If no 3rd arg then download to pwd
        if [ -z "${3}" ]; then
          BuildStructure
          DEST_DIR=${SD_DIR}
        else
          if [ -d ${3} ]; then
            DEST_DIR=${3}
          else
            printf "\n${ERRTXT}%s${NRMTXT}\n" \
              "The selected directory does not exist."
            exit 1
          fi
        fi
      else
        DisplayHelp
        exit 1
      fi
    fi
    ;;
  templates)
    if [[ $# -eq 1 ]]; then
      AvailableTemplates
    elif [[ $# -eq 2 && ${2} == "refresh" ]]; then
      RefreshTemplates
      AvailableTemplates
    else
      DisplayHelp
      exit 1
    fi
    ;;
  new)
    # Check the number of arguments
    if [[ $# != 3 ]]; then
        AvailableTemplates
      exit 1
    # Check if $2 is a digit
    elif [[ "$2" = *[[:digit:]]* ]]; then
      SetTemps      
      # Check if $2 is within the template index range
      if [[ "$2" -gt ${#TEMPS[*]} ]]; then
        AvailableTemplates
        printf "\n${ERRTXT}%s${NRMTXT}\n" \
          "Template index out of range!"
        exit 1
      else
          # Create a new document based on a template
        TEMPLATE_IND=$2
        DOC_TITLE=$3
        CreateNew
      fi
    else
      AvailableTemplates
      exit 1
    fi
    ;;
  copy)
    if [[ $# != 2 ]]; then
      CopyToClipboard $2 "0"
    else
      printf "${ERRTXT}%s${NRMTXT}\n" \
        "Invalid numer of arugments!"
      DisplayHelp
      exit 1
    fi
    ;;
esac
}

  # Cycle through the args setting valiables
CheckArgs () {

  if [ "${#}" = "0" ]; then
    DisplayHelp
    exit 1
  fi

while getopts ":ac:d:f:hln:o:rs:uw:ST" opt; do
    case $opt in
  h)
    DisplayHelp
    exit 0
    ;;


  S)
    #echo "fetch syntax file" >&2
    FETCHSYNTAX=1
    ;;
  s)
    #echo "apply syntax to APP $OPTARG" >&2
    SYNAPP=${OPTARG}
    ;;
  T)
    #echo "fetch templates" >&2
    FETCHTEMPLATES=1
    ;;


  w)
    #echo "Grab URL $OPTARG" >&2
    GETURL=${OPTARG}
    ;;
  f)
    #echo "READ from file $OPTARG" >&2
    GETFILE=${OPTARG}
    ;;
  d)
    #echo "Save to destination - $OPTARG" >&2
    DESTDIR=${OPTARG}
    ;;


  c)
    #echo "copy $OPTARG to clipboard" >&2
    COPYFILE=${OPTARG}
    ;;


  n)
    #echo "Create new article based upon $OPTARG" >&2
    USETEMPLATE=${OPTARG}
    ;;
  o)
    #echo "New File will be named $OPTARG" >&2
    NEWFILE=${OPTARG}
    ;;


  r)
    #echo "refresh templates" >&2
    REFRESHTEMPLATES=1
    ;;
  l)
    #echo "list templates" >&2
    LISTTEMPLATES=1
    ;;


  u)
    #echo "get updates"
    GETUPDATE=1
    ;;
  a)
    # Pull All, Prep Directory
    #echo "start prep"
    FETCHSYNTAX=1
    FETCHTEMPLATES=1
    ;;
  \?)
    WriteText 0 "${ERRTXT}" "Invalid option:-$OPTARG" 1
    WriteText 0 "" "" 1
    DisplayHelp
    exit 1
    ;;
  :)
    WriteText 0 "${ERRTXT}" "Option -$OPTARG requires an argument." 1
    WriteText 0 "" "" 1
    DisplayHelp
    exit 1
    ;;
  esac
done
}

  # Check if run as root, if root then exit
IsRoot() {
  # Check if the script is run as root
  if [ "$(id -u)" = "0" ]; then
    printf "${ERRTXT}%s${NRMTXT}" \
      "Do not run the script as root."
     exit 1
  fi
}

  # Check the input for all arguments for validity prior to running funcions
CheckValid() {
  if [ -n "${SYNAPP}" ]; then # confirmed
  #  PrepSyntax
    case "${SYNAPP}" in 
      vim)
        echo "Nothing">/dev/null
        ;;
      kate)
        echo "Nothing">/dev/null
        ;;
      *)
        WriteText 2 "${ERRTXT}" "Cannot set syntax info for ${SYNAPP}, please contact the authors of slackdoctool if you want it included." 1
        ISERROR=1
        ;;
    esac
  fi

  # Verify that the URL entered is not a local file or directory
  if [ -n "${GETURL}" ]&&[ -d ${GETURL} ]; then
    WriteText 2 "${ERRTXT}" "Directory ${GETURL} was input into -u. A Url Must be entered" 1
    ISERROR=1
  elif [ -n "${GETURL}" ]&&[ -f ${GETURL} ]; then
    WriteText 2 "${ERRTXT}" "File ${GETURL} was input into -u. A Url Must be entered" 1
    ISERROR=1
  fi

  # Verify that the FILE entered is not a local directory
  if [ -n "${GETFILE}" ]&&[ ! -f  ${GETFILE} ]; then
    WriteText 2 "${ERRTXT}" "File ${GETFILE} does not exist. Cannot continue." 1
    ISERROR=1
  fi

  if [ -n "${DESTDIR}" ]&&[ -z "${GETFILE}" ]&&[ -z "${GETURL}" ]; then
    WriteText 2 "${ERRTXT}" "Output directories are only valid when fetching URLs or a list of URLs, the option is being ignored" 1
  fi


  if [ ! -f ${COPYFILE} ]; then
    WriteText 2 "${ERRTXT}" "You cannot copy ${COPYFILE}, it does not exist." 1
    ISERROR=1
  fi

  if [ -n "${USERTEMPLATE}" ]&&[ ! -f "${TEMP_FILE}" ]; then
    WriteText 2 "${ERRTXT}" "No template list available, use the -r option to pull the updated list of templates."
  fi

  #if [ -n "${USERTEMPLATE}" ]&&[ -f "${TEMP_FILE}" ]&&[ -z "$(cat ${TEMP_FILE} | grep ${USETEMPLATE})" ]; then
  #  WriteText 2 "${ERRTXT}" "The template ${USETEMPLATE} does not exist." 1
  #  ISERROR=1
  #fi

#  if [ -n "${USETEMPLATE}" ]; then
#    if [ ! -f ${TEMP_FILE} ]; then
#      WriteText 2 "${ERRTXT}" "No template list available, use the -r option to pull the updated list of templates."
#    else
#      if [ -z "$(cat ${TEMP_FILE} | grep ${USETEMPLATE})"]; then
#        WriteText 2 "${ERRTXT}" "The template ${USETEMPLATE} does not exist." 1
#        ISERROR=1
#      fi
#    fi
#  fi

  #NEWFILE
  # Check for existance in the function, if exists then request to overwrite

  if [ -n "${ISERROR}" ]; then
    exit 1
  fi
}

  # Start Running through options in programatic order
RunFunctions() {
  if [ -n "${FETCHSYNTAX}" ]; then # confirmed
    GetSyntaxExample
    #echo "Fetch Syntax"
  fi

  if [ -n "${SYNAPP}" ]; then # confirmed
  #  PrepSyntax
    echo "Set Syntax for ${SYNAPP}"
  fi

  exit 1
  #REFRESHTEMPLATES
  if [ "${FETCHTEMPLATES}" = "1" ]; then
  #  PullTemplates
    echo "Pull the Templates"
  fi
  #LISTTEMPLATES

  if [ -n "${GETURL}" ]; then
    # If no destination directory is added default to the slackdoc dir
    if [ -z "${DESTDIR}" ]; then
      DESTDIR=${SD_DIR}
    fi
  #  PullPage
    echo "Pull Page ${GETURL} into ${DESTDIR}"
  fi

  if [ -n "${GETFILE}" ]; then
    # If no destination directory is added default to the slackdoc dir
    if [ -z "${DESTDIR}" ]; then
      DESTDIR=${SD_DIR}
    fi
    #  PullFromList
    echo "Pull Pages from ${GETFILE} into ${DESTDIR}"
  fi

  #COPYFILE

  #USETEMPLATE
  #NEWFILE

  if [ -n "${GETUPDATE} ]"; then
  #  CheckUpdate
    echo "Check for an update"
  fi
}

#DisplayHelp
#exit 1

# Check if run as root, if root then exit
IsRoot

# Test all Arguments
CheckArgs "$@"

# Verify that no invalid arguments are given
CheckValid

# If no errors, then run the functions
RunFunctions

# If it succeeds until now it processed successfully
exit 0
